Entendido, Comandante. El D√≠a 01 habr√° dejado los cimientos de datos y seguridad blindados. El D√≠a 02 es donde la presi√≥n se vuelve real: pasamos de la base de datos a la experiencia de usuario t√°ctica.

Aqu√≠ tienes los prompts de incursi√≥n para el D√≠a 02: HUD de Asedio e Interfaz de Validaci√≥n.

üõ°Ô∏è D√çA 02: HUD DE ASEDIO E INTERFAZ DE VALIDACI√ìN
Bloque 1: Arquitectura del HUD (Contadores de Horda)
Contexto: Necesitamos que el usuario sienta el peso de sus fallos cada vez que mira el Libro Rojo. Prompt:

"SAM, iniciamos el D√≠a 02. El motor de asedio ya calcula los enemigos, ahora necesito verlos.

Modifica la funci√≥n cargarMisiones() en el frontend (index.html) para que renderice los nuevos contadores de Exploradores, Orcos y Uruk-Hais en cada tarjeta de misi√≥n.

Usa Tailwind CSS para crear un dise√±o de 'Badge' agresivo:

Exploradores (Verde/Gris): üìç

Orcos (Rojo/Naranja): üëπ

Uruk-Hais (P√∫rpura/Negro): ‚öîÔ∏è

Implementa una l√≥gica visual: si un contador es 0, el icono debe estar en opacity-20. Si es > 0, debe resaltar con una peque√±a animaci√≥n de pulso.

Escribe un test de integraci√≥n con Jest/Testing Library que verifique que, si el backend env√≠a 3 orcos, el DOM muestra exactamente el icono de orco con el n√∫mero 3."

Bloque 2: El Interrogatorio de Gandalf (Componente de Juicio)
Contexto: Si el usuario no marc√≥ una tarea ayer, no puede seguir como si nada. Gandalf bloquea el paso. Prompt:

"HUD operativo. Ahora, implementemos el Protocolo de Bloqueo: El Juicio de Mithrandir.

Crea una secci√≥n modal (o un panel superior persistente) que se active si existen tareas con fallo_confirmado = false y cuya fecha sea anterior a hoy.

Este panel debe listar las tareas olvidadas y presentar dos opciones √∫nicas por cada una: 'Gesta Cumplida' o 'Ca√≠da en la Sombra'.

Al confirmar, debe llamar a la ruta /api/gandalf/judge que creamos ayer.

La interfaz debe impedir que se anoten nuevas gestas hasta que el juicio actual sea resuelto. Queremos 'fricci√≥n constructiva'. Aplica est√©tica de pergamino antiguo con filtros de desenfoque de fondo (backdrop-filter)."

Bloque 3: Din√°mica de la Sombra (Feedback Visual Global)
Contexto: Queremos que la app entera se 'oscurezca' si la horda es demasiado grande. Prompt:

"Mec√°nica de juicio integrada. Ahora, vamos a por el Efecto de Sombra Global.

Crea una funci√≥n en JS llamada actualizarNivelSombra() que sume el total de enemigos de todas las misiones fallidas.

Dependiendo de la suma, aplica filtros CSS al body de la p√°gina (ej: grayscale, brightness y sepia para dar un tono l√∫gubre).

1-5 enemigos: Cambio sutil.

6-15 enemigos: Pantalla notablemente m√°s oscura y desaturada.

+15 enemigos: El 'Ojo de Sauron' es total (puedes a√±adir una vi√±eta roja en los bordes).

Haz que Sam cambie su saludo inicial si el nivel de sombra es alto por uno m√°s preocupado: 'Se√±or... la oscuridad es densa hoy. Debemos actuar'. Tono t√©cnico, JARVIS, mentalidad Siempre a Muerte."

Bloque 4: Verificaci√≥n de Time Mocking en UI
Contexto: Asegurarnos de que nuestra 'trampa temporal' para tests tambi√©n funciona para ver la UI. Prompt:

"Finalizamos el D√≠a 02 con el Control del Tiempo.

A√±ade un peque√±o 'Panel de Desarrollador' oculto (solo visible en modo dev) que me permita cambiar la variable MOCK_DAYS_OFFSET desde la UI.

Al cambiarla, la web debe recargar las misiones y mostrar c√≥mo aparecen los Orcos y Uruk-Hais seg√∫n los d√≠as que hayamos 'adelantado'.

Escribe un test E2E (puede ser un script simple o con Cypress) que simule:

Paso 1: Crear tarea.

Paso 2: Adelantar 5 d√≠as.

Paso 3: Verificar que aparece 1 Uruk-Hai en la tarjeta. Entrega el c√≥digo con comentarios t√©cnicos precisos."